#!/usr/bin/env node

const { execSync } = require('child_process');
const program = require('commander');
const fs = require('fs');
const { resolve } = require('path');

function patchJson(path, ...patches) {
  console.log(`Patching ${path}...`);
  const json = fs.existsSync(path)
    ? JSON.parse(
      fs.readFileSync(path).toString() || '{}',
    )
    : {};

  for (const patch of patches) {
    patch(json);
  }

  fs.writeFileSync(
    path,
    JSON.stringify(json, null, 2),
    'utf-8',
  );
}

program
  .command('init')
  .option('-l, --lib-only', 'Only install library helpers')
  .action((cmd) => {
    const libOnly = cmd.libOnly;
    const source = resolve(__dirname, '..');
    const destination = process.cwd();

    if (source === destination) {
      console.log('Cannot install into itself.');
      return;
    }

    console.log(`Init ${source} -> ${destination}`);

    function copy(file) {
      const toFile = file.endsWith('_publish') ? file.slice(0, -8) : file;
      console.log(`Copying ${toFile}...`)
      fs.copyFileSync(resolve(source, file), resolve(destination, toFile));
    }

    copy('.editorconfig');
    copy('.gitignore_publish');
    copy('.npmignore_publish');
    copy('jest.config.js');
    if (!libOnly) {
      copy('nodemon.json');
    }
    copy('tsconfig.json');
    copy('tslint.json');

    try {
      fs.mkdirSync(resolve(destination, 'src'));
    } catch{ }
    try {
      fs.mkdirSync(resolve(destination, 'test'));
    } catch{ }
    try {
      fs.mkdirSync(resolve(destination, '.vscode'));
    } catch{ }

    patchJson(resolve(destination, 'package.json'),
      (package) => {
        Object.assign(package, {
          main: './dist/index.js',
          types: './src/index.ts',
        });
        package.scripts = Object.assign(package.scripts || {}, {
          build: 'rm -rf dist && npx tsc --outDir dist --sourceMap',
          lint: 'npx tslint --project tslint.json -t verbose',
          prepublishOnly: 'npm run lint && npm run build && npm version patch',
          test: 'npx jest --coverage',
        });
        if (!libOnly) {
          package.scripts = Object.assign(package.scripts || {}, {
            start: 'node -r ts-node/register src/index.ts',
            watch: 'npx nodemon',
          });
          delete package.nodemonConfig;
        }
        delete package.jest;
      }
    );

    patchJson(resolve(destination, '.vscode/settings.json'),
      (json) => {
        Object.assign(json, {
          'eslint.enable': false,
          'editor.formatOnSave': true,
          'files.trimTrailingWhitespace': true,
          'files.insertFinalNewline': true,
          'tslint.autoFixOnSave': true
        });
      }
    );

    patchJson(resolve(destination, '.vscode/extensions.json'),
      (json) => {
        json.recommendations = json.recommendations || [];
        json.recommendations.push('steoates.autoimport');
        json.recommendations.push('editorconfig.editorconfig');
        json.recommendations.push('christian-kohler.path-intellisense');
        json.recommendations.push('eg2.tslint');
        json.recommendations.push('waderyan.gitblame');
        json.recommendations.push('codezombiech.gitignore');
      }
    );

    console.log('Installing packages...');
    execSync('npm i -D @types/jest @types/node jest tslint typescript nodemon ts-node ts-jest');

    console.log('. Done');
  });

program.parse(process.argv);
